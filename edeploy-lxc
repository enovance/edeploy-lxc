#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2013 eNovance SAS <licensing@enovance.com>
#
# Author: Gon√©ri Le Bouder <goneri.lebouder@enovance.com>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import argparse
import augeas
import os
import shutil
import subprocess
import yaml

def start_bridge():
    for idx in range(get_len(conf['network']['bridge'])):
        bridge = get_value(conf['network']['bridge'], idx)
        subprocess.call(['brctl', 'addbr', bridge])
        gateway = get_value(conf['network']['gateway'], idx)
        if gateway:
            subprocess.call(['ifconfig', bridge, gateway])

def stop_bridge():
    for idx in range(get_len(conf['network']['bridge'])):
        bridge = get_value(conf['network']['bridge'], idx)
        subprocess.call(['ifconfig', bridge, 'down'])
        subprocess.call(['brctl', 'delbr', bridge])

def setup_ssh_key(conf, host):
    if not 'ssh_key' in conf['general']:
        return

    ssh_dir = '/var/lib/lxc/%s/rootfs/root/.ssh/' % get_value(host['name'], 0)
    os.makedirs(ssh_dir)
    shutil.copyfile(conf['general']['ssh_key'], ssh_dir + '/authorized_keys')

def get_value(val, idx):
    if type(val) is tuple or type(val) is list:
        return val[idx]
    else:
        if idx == 0:
            return val
        else:
            return None

def get_len(val):
    if type(val) is tuple or type(val) is list:
        return len(val)
    else:
        return 1

def stop():
    print "stopping"
    for host in conf['hosts']:
        hostname = get_value(host['name'], 0)
        aufs_rw_dir = "/tmp/base_aufs/%s" % hostname
        lxc_dir = "/var/lib/lxc/%s" % hostname
        try:
            subprocess.call(['lxc-kill', '-n', hostname ])
            subprocess.call(['lxc-stop', '-n', hostname ])
        except:
            pass

        if os.path.exists(lxc_dir):
            print("[%s]" % hostname)
            try:
                subprocess.call(['umount', lxc_dir ])
            except:
                print("Failed to umount %s" % lxc_dir)
            shutil.rmtree(lxc_dir)

            if os.path.exists(aufs_rw_dir):
                shutil.rmtree(aufs_rw_dir)

    stop_bridge()

def start():
    start_bridge()


    roles = []
    
    for host in conf['hosts']:
        if host['role'] not in roles:
            roles.append(host['role'])

    for role in roles:
        rootfs_dir = '/var/lib/lxc/%s/rootfs' % role
        if not os.path.exists(rootfs_dir):
            os.makedirs(rootfs_dir)
        subprocess.call(['rsync',
                         '-av',
                         '--delete',
                         '--numeric-ids',
                         '%s/%s/' % (conf['edeploy']['dir'], role),
                         rootfs_dir])
        subprocess.call(['tar', 'xf', '/usr/share/debootstrap/devices.tar.gz'],
                        cwd=rootfs_dir)

        if not os.path.exists(rootfs_dir + '/dev/pts'):
            os.makedirs(rootfs_dir + '/dev/pts')

        # work around for LXC bug, rmmod module on the host system
        shutil.copyfile(rootfs_dir + '/bin/true', rootfs_dir + '/bin/kmod')

    for host in conf['hosts']:
        hostname = get_value(host['name'], 0)
        print("[%s]" % hostname)

        aufs_rw_dir = "/tmp/base_aufs/%s" % hostname
        lxc_dir = "/var/lib/lxc/%s" % hostname
        rootfs_dir = lxc_dir + '/rootfs'
        
        if os.path.exists(lxc_dir):
            try:
                print "foo"
                subprocess.call(['lxc-kill', '-n', hostname ])
                subprocess.call(['lxc-stop', '-n', hostname ])
            except:
                pass
        else:
            os.makedirs(lxc_dir)
            
        if not os.path.exists(aufs_rw_dir):
            os.makedirs(aufs_rw_dir)

        subprocess.call(['mount', '-t', 'aufs', '-o', 'br=%s:%s' % (aufs_rw_dir, '/var/lib/lxc/%s' % host['role']), 'none', lxc_dir ])
        #mount -t aufs -o br=/tmp/base_aufs/os-ci-test4:/var/lib/lxc/basesys none /var/lib/lxc/os-ci-test4


        lxcConfFd = open(lxc_dir + '/config', 'w')
        for idx in range(get_len(conf['network']['bridge'])):
            lxcConfFd.write('''lxc.network.type = veth
lxc.network.flags = up
lxc.network.link = %s
lxc.network.name = eth%d

''' % (get_value(conf['network']['bridge'], idx), idx))

        lxcConfFd.write("lxc.rootfs = %s\n" % rootfs_dir +
                        "lxc.tty = 6\n" +
                        "lxc.pts = 1024\n" +
                        "lxc.utsname = %s\n" % hostname +
                        "lxc.cgroup.devices.deny = a\n" +
                        "lxc.aa_profile = unconfined\n" +
                        "lxc.cgroup.devices.allow = c 1:3 rwm\n" +
                        "lxc.cgroup.devices.allow = c 1:5 rwm\n" +
                        "lxc.cgroup.devices.allow = c 5:1 rwm\n" +
                        "lxc.cgroup.devices.allow = c 5:0 rwm\n" +
                        "lxc.cgroup.devices.allow = c 1:9 rwm\n" +
                        "lxc.cgroup.devices.allow = c 1:8 rwm\n" +
                        "lxc.cgroup.devices.allow = c 136:* rwm\n" +
                        "lxc.cgroup.devices.allow = c 5:2 rwm\n" +
                        "lxc.cgroup.devices.allow = c 10:236 rwm # /dev/mapper/control\n" +
                        "lxc.cgroup.devices.allow = c 10:237 rwm\n" +
                        "lxc.cgroup.devices.allow = c 254:0 rwm\n" +
                        "lxc.cgroup.devices.allow = b 7:* rwm # /dev/loop\n" +
                        "lxc.cgroup.devices.allow = b 252:* rwm # /dev/dm-*\n" +
                        "lxc.mount.entry = proc proc proc nodev,noexec,nosuid 0 0\n" +
                        "lxc.mount.entry = sysfs sys sysfs defaults  0 0\n" +
                        "lxc.cgroup.memory.limit_in_bytes = 536870912\n")
        lxcConfFd.close()

        debian_interfaces = rootfs_dir + '/etc/network/interfaces'
        if os.path.exists(debian_interfaces):
            netFd = open(debian_interfaces, 'w')
            netFd.write("auto lo\n")
            for idx in range(get_len(host['address'])):
                address = get_value(host['address'], idx)
                if address:
                    netFd.write('''
iface lo inet loopback
auto eth%d
iface eth%d inet static
    address %s
    netmask 255.255.255.0\n" +
 ''' % (idx, idx, address))
                    gateway = get_value(conf['network']['gateway'], idx)
                    if gateway:
                        netFd.write('    gateway %s\n' % gateway)
            netFd.close()
        else:
            fd = open(rootfs_dir + '/etc/init/lxc-sysinit.conf', 'w')
            fd.write("start on startup\n" +
                "env container\n" +
                "pre-start script\n" +
                "if [ \"x$container\" != \"xlxc\" -a \"x$container\" != \"xlibvirt\" ]; then\n" +
                "stop;\n" +
                "fi\n" +
                "initctl start tty TTY=console\n" +
                "rm -f /var/lock/subsys/*\n" +
                "rm -f /var/run/*.pid\n" +
                "telinit 3\n" +
                "exit 0;\n" +
                "end script\n"
            )
            fd.close()

            for idx in range(get_len(host['address'])):
                address = get_value(host['address'], idx)
                if address:
                    fd = open(rootfs_dir + '/etc/sysconfig/network-scripts/ifcfg-eth%d'
                              % idx, 'w')
                    fd.write(
                        "DEVICE=eth%d\n" % idx +
                        "ONBOOT=yes\n" +
                        "BOOTPROTO=static\n" +
                        "IPADDR=%s\n" % address +
                        "NETMASK=255.255.255.0\n")
                    gateway = get_value(conf['network']['gateway'], idx)
                    if gateway:
                        fd.write(
                            "GATEWAY=%s\n" % conf['network']['gateway'][idx]
                            )
                fd.close()
            fd = open(rootfs_dir + '/etc/sysconfig/network', 'w')
            fd.write(
                "NETWORKING=yes\n" +
                "HOSTNAME=%s.%s\n" % (hostname, conf['network']['domain'])
            )
            fd.close()

        hostFd = open(rootfs_dir + '/etc/hosts', 'w')
        hostFd.write(
            "127.0.0.1 %s.%s %s localhost\n" % (hostname,
                                                get_value(conf['network']['domain'], 0),
                                                hostname) +
            "::1     localhost ip6-localhost ip6-loopback\n" +
            "ff02::1 ip6-allnodes\n" +
            "ff02::2 ip6-allrouters\n"
        )
        for h in conf['hosts']:
            for idx in range(get_len(h['name'])):
                name = get_value(h['name'], idx)
                address = get_value(h['address'], idx)
                domain = get_value(conf['network']['domain'], idx) or \
                    get_value(conf['network']['domain'], 0)
                if name and address and domain:
                    hostFd.write("%s %s.%s %s\n" % (address, name, domain, name))
        hostFd.close()

        a = augeas.Augeas(root=rootfs_dir)
        a.set("/files/etc/hostname/hostname", "%s" % hostname)
        a.save()

        setup_ssh_key(conf, host)

        if 'cloudinit' in host:
            cloudinit_name = os.path.basename(host['cloudinit']).replace('.cloudinit', '')
            print("    setting cloudinit flat file datasource")
            nocloud_dir = rootfs_dir + '/var/lib/cloud/seed/nocloud'
            os.makedirs(nocloud_dir)
            open(os.path.join(nocloud_dir, 'user-data'), 'w').write(open(host['cloudinit']).read())
            open(os.path.join(nocloud_dir, 'meta-data'), 'w').write('local-hostname: %s' % hostname)
            open(rootfs_dir + '/etc/cloud/cloud.cfg.d/90_dpkg.cfg', 'w').write('''
dsmod: local

datasource_list: [ NoCloud ]
''')
        print("    launching %s" % host['role'])
        subprocess.call(['lxc-start', '-d', '-L', '/tmp/lxc-%s.log' % hostname,
                         '-n', hostname ])

parser = argparse.ArgumentParser()
parser.add_argument('action', help='action', choices=['stop', 'start', 'restart'])
parser.add_argument('--config', help='configuration file', required=True)

args = parser.parse_args()

stream = file(args.config, 'r')
conf = yaml.load(stream)

if args.action == 'start':
    start()
elif args.action == 'stop':
    stop()
elif args.action == 'restart':
    stop()
    start()
